
# 🤖 AI 节点编辑器 (AI Node Editor)  Workflow Studio 🌟

## 1. 🚀 项目简介

AI 节点编辑器是一款基于 Web 🕸️ 的可视化AI工作流构建和管理应用程序。用户可以通过拖拽节点 🧩、连接端口 🔗 的方式，在画布 🖼️ 上直观地创建、组织和运行复杂的 AI 及数据处理流程。应用支持多种内置节点类型，并允许用户创建自定义 AI 节点、AI 工具以及自定义界面和数据处理逻辑，以满足多样化的需求。

本应用的核心目标是提供一个灵活、强大且易于使用的平台，帮助开发者和 AI 从业者高效地设计、实验和部署 AI 工作流。

## 2. ✨ 核心功能

*   👁️‍🗨️ **可视化节点编辑器**:
    *   在无限画布上通过拖拽方式添加、移动和组织节点。
    *   通过连接节点的输入和输出端口来定义数据流和执行顺序。
    *   支持画布的平移 ↔️ 和缩放 🔍，方便查看大型工作流。
    *   提供框选、对齐等辅助编辑功能。

*   🧩 **丰富的节点类型**:
    *   **核心与流程控制**: 开始节点 ▶️、条件判断节点 🤔、数据触发节点 ⚡️、数据同步节点 🔄、数据延迟节点 ⏳。
    *   **输入与交互**: 用户输入节点（文本）⌨️、自定义UI节点（HTML/CSS/JS）🎨。
    *   **数据处理**: 数据组合节点 ➕、数据拆分节点 ➖、数据合并节点 🖇️、全局变量节点 📦、自定义数据处理节点（JavaScript）✍️。
    *   **AI 能力**: AI 文本生成节点 🤖✍️（支持 Gemini 和 OpenAI）、AI 模型选择节点 ⚙️、AI 选项决策节点 💡。
    *   **模块化**: 子流程输入/输出节点 🧱➡️、子流程实例节点 🔄。
    *   支持用户通过界面创建**自定义AI节点**✨。

*   🔗 **连接管理**:
    *   可视化连接不同节点的端口。
    *   支持数据类型校验 ✅，确保连接的有效性。
    *   连接线高亮和动态路径显示。

*   📋 **属性检查器**:
    *   选中节点、连接、工作流或画布区域后，在右侧属性检查器中查看和编辑其详细属性。
    *   节点特定配置，如 AI 参数、条件表达式、自定义逻辑等。

*   📑 **多标签页管理**:
    *   支持同时打开和编辑多个工作流（主流程或子流程）。
    *   每个标签页独立管理其画布状态、历史记录和执行状态。

*   🗂️ **项目与文件管理**:
    *   支持从**本地文件系统** 📁 打开和保存工作流文件 (`.json` 格式) 📄。
    *   提供**内部演示项目** 🧪，方便快速上手和体验。
    *   支持整个项目的导入 📥 和导出 📤。

*   🤖 **AI 服务集成**:
    *   内置对 Google Gemini API 的支持（通过 `@google/genai` SDK）💎。
    *   支持通过配置 OpenAI API 兼容的端点（如 Google AI Studio 的 OpenAI 兼容端点或其他 OpenAI 服务）来使用 OpenAI 模型 🧠。
    *   通过**全局设置** 🌍 统一管理和配置不同 AI 模型的 API 密钥、API URL 等。

*   🎨 **自定义能力**:
    *   **自定义 AI 节点**: 用户可以通过界面配置输入、输出、AI 模型参数、默认提示词等，快速创建特定功能的 AI 节点。
    *   **AI 工具 (Tools / Function Calling)** 🛠️: 支持为 AI 节点配置工具，实现结构化输出和函数调用。应用内置基础工具，并支持用户在“AI 工具浏览器”中注册自定义工具（基于 Gemini FunctionDeclaration 规范）。
    *   **自定义 UI 节点**: 允许开发者使用 HTML, CSS, 和 JavaScript 🌐 创建自定义的交互式用户界面。UI 内部可以通过 `window.aiStudioBridge.sendOutput()` 与工作流引擎通信，触发输出端口。
    *   **自定义数据处理节点**: 允许用户编写 JavaScript </> 代码片段来处理输入数据，并生成输出。脚本中可以通过 `inputs` 对象访问端口数据，通过 `return` 语句输出结果。

*   ▶️ **工作流执行与调试**:
    *   可视化运行工作流，高亮显示正在执行的节点和数据流动状态。
    *   支持终止 ⏹️ 正在运行的工作流。
    *   节点执行状态实时反馈（运行、完成、错误 ❌、等待 ⏳、暂停 ⏸️ 等）。
    *   错误信息和执行详情展示在属性检查器中。

*   📜 **历史记录 (撤销/重做)**:
    *   画布上的大部分操作（如添加/删除节点、连接、移动节点、更新节点数据等）都会被记录。
    *   支持撤销 ⏪ 和重做 ⏩ 操作，方便用户回溯和修改。

*   🔲 **画布区域定义 (Area Definition)**:
    *   允许用户在画布上创建和命名矩形区域，用于视觉上组织和注释节点。
    *   区域的颜色、透明度、边框、文本样式等均可自定义。

*   🧱 **节点组 (Node Groups)**:
    *   允许用户将画布上选定的多个节点及其内部连接保存为一个可复用的“节点组”。
    *   节点组可以从“节点组库”面板拖拽到画布上，快速实例化一组预设的节点和连接。
    *   支持配置拖拽节点组到画布时是否自动创建同名区域。

*   🔄 **子流程 (Sub-workflows)**:
    *   支持将一个完整的工作流定义为一个“子程序”。
    *   通过“子流程输入”和“子程序输出”节点定义子流程的参数接口。
    *   在其他工作流中，可以通过“子流程实例”节点来调用和执行子流程，实现工作流的模块化和复用。
    *   “程序接口”面板用于管理当前子流程的输入输出定义。

*   🌍 **全局设置**:
    *   **AI 模型配置**: 集中管理不同 AI 服务的配置组（如 Gemini, OpenAI 等）。用户可以添加自定义配置组，或编辑预定义配置组的 API 密钥、API URL 和默认模型等。
        *   支持从环境变量 (`process.env.API_KEY`) 加载 Gemini API 密钥。
        *   支持测试配置的连通性 ✅。
    *   **主题设置**: (占位功能) 未来可支持应用整体外观主题的切换 🎨。

## 3. 🛠️ 技术栈

*   **前端框架**: React (v19) ⚛️
*   **语言**: TypeScript 🔷
*   **UI 库与样式**: Tailwind CSS 🌬️
*   **AI SDK**: `@google/genai` (用于 Google Gemini API) 💎
*   **核心逻辑与状态管理**:
    *   大量使用 React Hooks (useState, useEffect, useCallback, useMemo, useRef) 进行组件状态和逻辑管理。
    *   通过自定义 Hooks (如 `useAppOrchestration`, `useNodeManager`, `useConnectionManager` 等) 组织和管理应用的核心功能模块。
    *   部分模块化功能（如历史记录 📜、剪贴板 📋、上下文菜单 👇）通过独立的 Hook 实现。
*   **模块化与代码组织**:
    *   按功能特性 (features) 组织代码目录，例如 `nodes/`, `features/connections/`, `features/tabs/` 等。
    *   节点定义、渲染器 (Renderer)、检查器 (Inspector) 和执行器 (Executor) 分离。
    *   CSS-in-JS 思想主要通过 Tailwind CSS 的原子化类名实现，自定义样式较少。

## 4. 📖 使用指南

### 4.1 🔑 环境准备

*   **API 密钥**:
    *   若要使用 **Google Gemini** 服务 💎，必须在运行应用的环境中正确设置 `API_KEY` 环境变量。例如，在本地开发时，可以在启动脚本或 `.env` 文件中配置。
        ```bash
        # 示例 (具体设置方式取决于您的运行环境)
        export API_KEY="YOUR_GEMINI_API_KEY"
        ```
    *   对于其他 AI 服务（如 OpenAI 🧠 或 Google AI Studio 的 OpenAI 兼容端点），API 密钥需要在应用内的“全局设置” 🌍 -> “AI 模型配置”中进行配置。
 
*  本项目支持本地部署，只需执行下面四步：
   - 安装Node.js，并下载解压项目文件
   - 在文件夹内部右键打开终端，执行 `npm install`
   - 再执行 `npm run dev`
   - 然后打开终端提供的本地链接即可

### 4.2 🖱️ 基本操作

1.  **启动应用**: 在浏览器 🌐 中打开 `index.html`。
2.  **选择项目源**:
    *   **内部演示项目** 🧪: 快速体验应用功能。
    *   **本地文件夹** 📁: 选择您本地文件系统中的一个文件夹作为项目根目录。应用将在此目录中读取和保存 `.json` 工作流文件。
3.  **创建/打开工作流**:
    *   点击顶部标签栏右侧的 `➕`按钮新建一个空白工作流页面。
    *   如果使用本地文件夹项目源，可以通过左侧“项目文件”面板双击 `.json` 文件来打开已有的工作流。
    *   通过顶部菜单“文件” -> “导入页面...” 导入单个工作流文件。
4.  **添加节点** 🧩:
    *   从左侧“节点列表”面板中选择一个节点类型。
    *   在画布的空白区域单击，即可放置所选节点。
    *   或者，直接从“节点列表”面板将节点类型拖拽到画布上。
5.  **连接节点** 🔗:
    *   鼠标悬停在节点的一侧（输入或输出区域）会显示端口。
    *   点击一个端口并拖拽，可以拉出连接线。
    *   将连接线拖拽到另一个兼容的端口上并松开鼠标，即可建立连接。
6.  **配置节点** ⚙️:
    *   单击选中一个节点。
    *   在右侧“属性检查器”面板中，可以编辑节点的标题、特定参数（如 AI 节点的默认提示词、模型配置，自定义UI节点的 HTML/CSS 代码等）、以及管理动态端口（如果节点支持）。
7.  **运行工作流** ▶️:
    *   点击顶部菜单栏右侧的“运行”按钮。
    *   观察画布上节点的执行状态高亮变化。
    *   选中节点，可以在属性检查器中查看其运行详情（如输出内容、Token 数量、错误信息 ❌ 等）。
8.  **保存工作流** 💾:
    *   通过顶部菜单“文件” -> “保存文件” (快捷键 Ctrl+S 或 Cmd+S) 来保存当前活动标签页的工作流。
        *   若为本地项目文件，会保存到对应的本地文件。
        *   若为内部项目或未关联本地文件的新标签页，会标记为“已在应用内保存”。如需持久化到本地，请使用“另存为...”或“导出页面”。

### 4.3 🌟 高级功能

*   **创建自定义 AI 节点** ✨:
    1.  通过顶部菜单“添加” -> “自定义 AI 节点”打开创建模态框。
    2.  配置节点名称、描述、外观（标题背景色、文字颜色）、AI 参数（模型配置组、系统指令、默认提示词、Temperature 等）。
    3.  定义节点的输入和输出端口（标签、数据类型、是否必需）。
    4.  对于输出端口，可以选择是否关联一个 AI 工具 (Function Calling) 🛠️ 来结构化输出。
    5.  保存后，新创建的自定义 AI 节点会出现在“节点列表”的“自定义 AI 节点”分类下。

*   **管理和使用 AI 工具** 🛠️:
    1.  通过顶部菜单“查看” -> “AI 工具”打开“AI 工具浏览器”。
    2.  这里会列出所有内置和用户自定义的 AI 工具。
    3.  可以添加新的自定义工具，定义其名称、描述和参数结构 (符合 Gemini FunctionDeclaration 规范)。
    4.  在 AI 文本生成节点或自定义 AI 节点的属性检查器中，可以为输出端口选择要调用的 AI 工具。

*   **设计和使用子流程** 🔄:
    1.  点击顶部标签栏 `➕` 按钮旁的下拉菜单（或通过特定操作）创建一个新的“子程序”类型的标签页。
    2.  在该子程序标签页的画布上，使用“子程序输入”和“子程序输出”节点来定义其接口。
        *   在这些接口节点的属性检查器中配置端口名称、数据类型和是否必需。这些配置将决定“子流程实例”节点上的端口外观。
    3.  在“程序接口”面板（左侧边栏）可以统一查看和管理当前子流程的输入输出定义，并可以添加“逻辑接口”（不直接对应画布节点的接口）。
    4.  子流程定义会自动出现在“子程序库”面板中。
    5.  在主工作流或其他子流程中，从“子程序库”面板拖拽一个子流程到画布上，即可创建一个“子流程实例”节点来调用它。

*   **管理全局 AI 模型配置** 🌍⚙️:
    1.  通过顶部菜单“查看” -> “全局设置”打开模态框。
    2.  选择“AI 模型配置”分类。
    3.  这里列出了预定义的配置组（如 Gemini 环境变量、Gemini API 示例、OpenAI API 示例等）和用户自定义的配置组。
    4.  可以添加新的配置组，或为非环境变量的配置组编辑 API 密钥、API URL 和默认模型名称等。
    5.  这些配置组可以在 AI 相关节点（如 AI 文本生成、AI 模型选择、自定义 AI 节点）中被引用，以决定实际调用的 AI 服务和参数。

## 5. 💻 开发

### 5.1 项目结构 (概览) 📂

项目主要文件结构：
*   `index.html`: 应用入口 HTML 文件。
*   `index.tsx`: React 应用主入口。
*   `App.tsx`: 应用主组件，负责整体布局和状态协调。
*   `components/`: 通用 UI 组件 (如 Sidebar, TopBar, Modals)。
*   `features/`: 应用核心功能模块 (如 canvas, connections, nodes, tabs, execution, projectFiles, history, ai, subworkflows, nodeGroups)。
*   `hooks/`: 自定义 React Hooks，用于封装和复用逻辑。
*   `layout/`: 布局相关的组件。
*   `nodes/`: 内置节点类型的定义、渲染器、检查器和执行器。
    *   每个节点类型通常在一个单独的文件夹中，包含 `Definition.ts`, `Renderer.tsx` (如果自定义), `Inspector.tsx`, `Executor.ts`。大部分节点现在使用 `UniversalNodeRenderer`。
*   `services/`: 服务层代码 (如 Gemini 服务交互)。
*   `theme/`: 主题和样式定义 (如 `vscodeDark.ts`)。
*   `types.ts`: 全局 TypeScript 类型定义。
*   `utils/`: 通用工具函数。

### 5.2 如何添加新节点 🧩➕

1.  **创建节点文件夹**: 在 `nodes/` 目录下为新节点创建一个文件夹，例如 `nodes/MyNewNode/`。
2.  **定义 (Definition.ts)**:
    *   创建 `Definition.ts` 文件。
    *   定义节点的 `type` (唯一键)、`label` (显示名称)、`description`、`defaultTitle`、尺寸 (`width`, `height`)、颜色 (`headerColor`, `bodyColor`)。
    *   定义 `inputs` 和 `outputs` 数组，每个端口包含 `id`, `label`, `dataType`, `shape`, `isPortRequired` 等属性。
    *   定义 `defaultData` 对象，包含节点实例的默认内部数据。
    *   如果节点有自定义内容区域，定义 `customContentHeight`, `customContentRenderer` (React 组件), `customContentTitle`。
3.  **执行器 (Executor.ts)**:
    *   创建 `Executor.ts` 文件。
    *   导出一个异步函数 `executeMyNewNode(node, inputs, services, executionContextId?, customTools?)`。
    *   该函数接收当前节点实例、解析后的输入数据、工作流服务对象、执行上下文ID和自定义工具列表。
    *   根据输入和节点数据执行逻辑，并返回一个包含 `outputs` (各输出端口的数据) 和可选的 `executionDetails` (如 Token 数量、错误信息 ❌) 的对象。
4.  **检查器 (Inspector.tsx)**:
    *   创建 `Inspector.tsx` 文件。
    *   导出一个 React 组件 `MyNewNodeInspector(props)`，接收 `SpecificNodeInspectorProps`。
    *   使用 `BaseNodeInspector` 作为基础，在其 `children` 中添加特定于此节点的配置 UI。
    *   通过 `props.updateNodeData(nodeId, dataUpdates)` 更新节点数据。
5.  **渲染器 (Renderer.tsx)**: (可选)
    *   如果节点的渲染逻辑与 `UniversalNodeRenderer` 不同（例如，需要非常特殊的内部布局或交互），则创建 `Renderer.tsx`。
    *   通常，`UniversalNodeRenderer` 配合 `customContentRenderer` 已足够灵活。
6.  **集成**:
    *   在 `nodes/index.ts` 中导入新节点的定义对象 (包含 Definition, Renderer, Inspector, Executor)，并将其添加到 `ALL_NODE_DEFINITIONS` 数组中。
    *   在 `nodes/nodeCategories.ts` 中将新节点的 `TYPE_KEY` 添加到一个合适的分类下，使其出现在节点列表面板中。

## 6. 🔮 未来展望 (示例)

*   更完善的错误处理 ❌ 和用户反馈 👍。
*   支持更多类型的 AI 模型 🤖 和数据源 📊。
*   节点内嵌实时预览 ✨ 和调试功能 🐞。
*   工作流版本控制 ⏳。
*   团队协作功能 🤝。
*   性能优化 🚀，支持更大规模的工作流。

---

感谢使用 AI 节点编辑器！🙏
